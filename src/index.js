import postcssNested from 'postcss-nested';
import postcssSafeParser from 'postcss-safe-parser';
import { loopWhile } from 'deasync';
import * as t from 'babel-types';
import {
  isStyled,
  isPureHelper,
  isInjectGlobalHelper,
} from 'babel-plugin-styled-components/lib/utils/detectors';
import postcssNamespace from './postcssNamespace';

const makePlaceholder = index => `/* EXPRESSION_PLACEHOLDER_${index} */`;
const makePlaceholderIdentifier = index => `/* EXPRESSION_PLACEHOLDER_${index}_Identifier */`;
// matches BOTH patterns so we don't need to change how we store values
const PLACEHOLDER_PATTERN = /\/\* EXPRESSION_PLACEHOLDER_(\d+)(?:_Identifier)? \*\//g;

const replacementNodes = new WeakSet();

const taggedTemplateVisitor = (path, state) => {
  const { namespace } = state.opts;
  const { node } = path;
  const {
    tag,
    quasi: { quasis, expressions },
  } = node;

  if (!namespace) throw new Error('option `namespace` must be provided');

  // Ignore nodes generated by this visitor, to prevent infinite loops
  if (replacementNodes.has(node)) return;

  // Ignore templates tagged with anything other than `styled(x)`
  if (!isStyled(t)(tag, state)) return;
  if (isPureHelper(t)(tag, state)) return;
  if (isInjectGlobalHelper(t)(tag, state)) return;

  // Convert the tagged template to a string, with ${} expressions replaced with placeholders
  const originalStyleString = quasis
    .map((quasi, i) => {
      // is the interpolation NOT an Identifier (i.e. is it most likely not an interpolated Selector?)
      if (expressions[i] && expressions[i].type !== 'Identifier') {
        return quasi.value.raw + makePlaceholder(i);
      } 
      // we think it's an interpolated Selector (could catch mixins that aren't arrow functions)
      else if (expressions[i] && expressions[i].type) {
        return quasi.value.raw + makePlaceholderIdentifier(i);
      }
      // otherwise just 
      else {
        return quasi.value.raw;
      }
    }
    )
    .join('');

  // Run the string through postcss-nested to "unwrap" any nested style rules
  let postcssNestedResult;
  postcssNested
    .process(`& { ${originalStyleString} }`, {
      from: undefined,
      parser: postcssSafeParser,
    })
    .then(asyncResult => {
      postcssNestedResult = asyncResult;
    })
    .catch(err => {
      postcssNestedResult = err;
    });
  loopWhile(() => postcssNestedResult == null);
  if (postcssNestedResult instanceof Error) throw postcssNestedResult;

  // Run the string through our namespace plugin to prefix each selector with the given namespace
  let postcssNamespaceResult;
  postcssNamespace
    .process(
      postcssNestedResult.css,
      { from: undefined, parser: postcssSafeParser },
      { namespace }
    )
    .then(asyncResult => {
      postcssNamespaceResult = asyncResult;
    })
    .catch(err => {
      postcssNamespaceResult = err;
    });
  loopWhile(() => postcssNamespaceResult == null);
  if (postcssNamespaceResult instanceof Error) throw postcssNamespaceResult;

  // Replace the expression placeholders to form a new, properly namespaced tagged template
  const processedString = postcssNamespaceResult.css;
  const newTemplateStringChunks = [];
  const newTemplateExpressions = [];
  let placeholderMatch;
  let prevLastIndex = 0;

  while ((placeholderMatch = PLACEHOLDER_PATTERN.exec(processedString))) {
    const chunkBefore = processedString.slice(
      prevLastIndex,
      placeholderMatch.index
    );
    newTemplateStringChunks.push(chunkBefore);

    newTemplateExpressions.push(expressions[placeholderMatch[1]]);

    prevLastIndex = PLACEHOLDER_PATTERN.lastIndex;
  }
  newTemplateStringChunks.push(processedString.slice(prevLastIndex));
  PLACEHOLDER_PATTERN.lastIndex = 0;

  // Insert the replacement node and store a reference to prevent us from reprocessing it
  const replacementNode = t.taggedTemplateExpression(
    tag,
    t.templateLiteral(
      newTemplateStringChunks.map((str, i) =>
        t.templateElement(
          { raw: str, cooked: str.replace(/\\\\/g, '\\') },
          i === newTemplateStringChunks.length - 1
        )
      ),
      newTemplateExpressions
    )
  );
  replacementNodes.add(replacementNode);
  path.replaceWith(replacementNode);
};

export default function() {
  return {
    visitor: {
      TaggedTemplateExpression: taggedTemplateVisitor,
    },
  };
}
