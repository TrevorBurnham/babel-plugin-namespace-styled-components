import postcssNested from 'postcss-nested';
import postcssSafeParser from 'postcss-safe-parser';
import { loopWhile } from 'deasync';
import * as t from 'babel-types';
import {
  isStyled,
  isPureHelper,
  isInjectGlobalHelper,
} from 'babel-plugin-styled-components/lib/utils/detectors';
import postcssNamespace from './postcssNamespace';

const PLACEHOLDER_PREFIX = 'EXPRESSION_PLACEHOLDER_';
const PLACEHOLDER_PATTERN = /EXPRESSION_PLACEHOLDER_(\d+)/g;

const replacementNodes = new WeakSet();

const taggedTemplateVisitor = (path, state) => {
  const { namespace } = state.opts;
  const { node } = path;
  const {
    tag,
    quasi: { quasis, expressions },
  } = node;

  if (!namespace) throw new Error('option `namespace` must be provided');

  // Ignore nodes generated by this visitor, to prevent infinite loops
  if (replacementNodes.has(node)) return;

  // Ignore templates tagged with anything other than `styled(x)`
  if (!isStyled(t)(tag, state)) return;
  if (isPureHelper(t)(tag, state)) return;
  if (isInjectGlobalHelper(t)(tag, state)) return;

  // Convert the tagged template to a string, with ${} expressions replaced with placeholders
  const originalStyleString = quasis
    .map((quasi, i) =>
      expressions[i]
        ? quasi.value.raw + PLACEHOLDER_PREFIX + i
        : quasi.value.raw
    )
    .join('');

  // Run the string through postcss-nested to "unwrap" any nested style rules
  let postcssNestedResult;
  postcssNested
    .process(`& { ${originalStyleString} }`, {
      from: undefined,
      parser: postcssSafeParser,
    })
    .then(asyncResult => {
      postcssNestedResult = asyncResult;
    })
    .catch(err => {
      postcssNestedResult = err;
    });
  loopWhile(() => postcssNestedResult == null);
  if (postcssNestedResult instanceof Error) throw postcssNestedResult;

  // Fix for reported bug where postcss-nested emits malformed CSS after each closing "}"
  postcssNestedResult.css = postcssNestedResult.css.replace(/}\S+/g, '}');

  // Run the string through our namespace plugin to prefix each selector with the given namespace
  let postcssNamespaceResult;
  postcssNamespace
    .process(
      postcssNestedResult.css,
      { from: undefined, parser: postcssSafeParser },
      { namespace }
    )
    .then(asyncResult => {
      postcssNamespaceResult = asyncResult;
    })
    .catch(err => {
      postcssNamespaceResult = err;
    });
  loopWhile(() => postcssNamespaceResult == null);
  if (postcssNamespaceResult instanceof Error) throw postcssNamespaceResult;

  // Replace the expression placeholders to form a new, properly namespaced tagged template
  const processedString = postcssNamespaceResult.css;
  const newTemplateStringChunks = [];
  const newTemplateExpressions = [];
  let placeholderMatch;
  let prevLastIndex = 0;

  while ((placeholderMatch = PLACEHOLDER_PATTERN.exec(processedString))) {
    const chunkBefore = processedString.slice(
      prevLastIndex,
      placeholderMatch.index
    );
    newTemplateStringChunks.push(chunkBefore);

    newTemplateExpressions.push(expressions[placeholderMatch[1]]);

    prevLastIndex = PLACEHOLDER_PATTERN.lastIndex;
  }
  newTemplateStringChunks.push(processedString.slice(prevLastIndex));
  PLACEHOLDER_PATTERN.lastIndex = 0;

  // Insert the replacement node and store a reference to prevent us from reprocessing it
  const replacementNode = t.taggedTemplateExpression(
    tag,
    t.templateLiteral(
      newTemplateStringChunks.map((str, i) =>
        t.templateElement(
          { raw: str, cooked: str.replace(/\\\\/g, '\\') },
          i === newTemplateStringChunks.length - 1
        )
      ),
      newTemplateExpressions
    )
  );
  replacementNodes.add(replacementNode);
  path.replaceWith(replacementNode);
};

export default function() {
  return {
    visitor: {
      TaggedTemplateExpression: taggedTemplateVisitor,
    },
  };
}
